# RNA-Seq differential expression analysis using Kallisto and DESeq2
Here we describe a pipeline to analyse RNA sequencing data (NovaSeq 6000 PE150). Overall, we need to 1) check the quality of raw data (FASTQC analyisis), 2) filter te raw data (FASTP), and 3) estimate the gene expression of the RNAseq data (KALLISTO). Kallisto is a program for quantifying abundances of transcripts from bulk RNA-Seq data. It is based on the pseudoalignment of reads against the transcriptome of a species for rapid estimation of transcript expression. Of note, this pipeline is described considering that the genome/transcriptome of the species that we are working with is publicly available.

**TABLE OF CONTENTS**
   * [1. Quality control with FastQC](#1-quality-control-with-FastQC)
   * [2. Filtering using fastp](#2-filtering-using-fastp)
   * [3. Quantification using kallisto](#3-quantification-using-kallisto)
   * [4. Differential expression using DESeq2](#4-differential-expression-using-DESeq2)

## 0. Download files
The first step is downloading the raw sequencing files into our server of computer. Most sequencing providers will upload the raw files into an FTP server. The files can usually be downloaded using the Unix command "wget":
```
wget https://...
```
Paired-end sequencing generates two output fastq files for each sample. These usually end in "_1.fastq.gz" and "_2.fastq.gz" (but "_R1_001.fastq.gz" and "_R2_001.fastq.gz" are also frequent). The files are usually compressed using gunzip - there is no need to unzip them, most software will work with gunzipped files. The fastq files will usually come with corresponding MD% files to check that the integrity of the downloaded files.


## 1. Quality control with FastQC 
Once we have downloaded the fastq files, it is good practice to check their quality. It can be done using the software [FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/). The command to run FastQC in a fastq file is:

```
fastqc sampleA_1.fastq.gz
```
Most of the time, it will be more convinient to run FastQC for all samples at once:
```
fastqc *fastq.gz
```
Two files will be generated by FastQC: fastqc.zip and fastqc.html. To visualise them, the easiest way is to open the html files with a web browser. You can find output examples in the webpage of [FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/). RNA-Seq data usually present warnings for some of the categories, such as "Per base sequence context" or "Sequence duplication levels". As long as the issues are not extrime, this is normal and nothing to worry about.

This quality control is just to visually inspect the quality of the sequencing data, but it does not alter the fastq files in any way. In fact, this step can even be skipped, although it is worth practice to check the quality of the sequencing output to discards any problems connected to RNA extraction, library preparation or sequencing.


## 2. Filtering using fastp
While not absolutely necessary, removing low quality reads and bases can improve downstream results. [Fastp](https://github.com/OpenGene/fastp) can rapidly filter fastq files, removing low quality reads, contaminating sequence, low complexity reads (repeats), short reads, etc. An example command would be:
```
fastp -i sampleA_1.fastq.gz -I sampleA_2.fastq.gz -o sampleA_filtered_1.fastq.gz -O sampleA_filtered_2.fastq.gz -q 15 -l 30 -h sampleA.html
```
Fastp takes two paired fastq files (options -i and -I) and removes bases with Phred quality below 15 (-q 15) and reads that end up with a lenght of less than 30 bases (-l 30). The raw files remain intact, and two new filtered files are generated (options -o and -O). -h specifies names for the html file with plots showing the read quality before and after filtering  (potential alternative to FastQC).


## 3. Quantification using kallisto
[Kallisto](https://pachterlab.github.io/kallisto/about) is a software for rapidly quantifying abundances of transcripts from RNA-seq data. It is based on a pseudoalignment strategy using the transcriptome of a species as reference. This reference transcriptome needs to be downloaded and indexed before expression can be quantified. Transcriptomes for species with sequenced genomes can be obtained from Ensembl or NCBI (and downloaded using "wget").

To create the index of the transcriptome, the command is:
```
kallisto index -i transcriptome.fa.idx transcriptome.fa
```
To estimate the expression of each transcript in each sample, we use the `quant` function of kallisto:
```
kallisto quant -i transcriptome.fa.idx -o sampleA -b 100 sampleA_filtered_1.fastq.gz sampleA_filtered_2.fastq.gz 
```
The results for each sample will be a separate folder with the name of the sample (-o). That folder will contain three files: abundance.h5, abundance.tsv, and run_info.json

## 4. Differential expression using DESeq2
The remaining of the pipeline is performed in R, and requires the installation of various packages:
```
library(tximportData)
library(tximport)
library(readr)
library(biomaRt)
library(DESeq2)
library(PCAtools)
library(EnhancedVolcano)
library("pheatmap")
```
### 4.1. Loading Kallisto expression estimates
To read the output of Kallisto, we first store the route to the directory where the folders are, and move to that folder:
```
dir <- "/path/to/kallisto/output/folder"
setwd(dir)
```
We store the names of all the samples (the outputs of kallisto will be in folders with their names):
```
samples  <- list.files()
```
And use this to generate an object with the path to the folder of each specific sample:
```
files <- file.path(dir, samples$V1, "abundance.h5")
names(files) <- samples
```
By default, Kallisto quantifies the expression of every transcript in the transcriptome of the species (i.e. including the different isoforms for each gene), but in most scenarios we will be interested in obtaining gene-level differential expression. Therefore, we need to match the isoforms to genes. If we are using a reference transcriptome from Ensembl, we can get this information using the [biomaRt package](https://bioconductor.org/packages/release/bioc/html/biomaRt.html).

First we need to find the name of the database of our species:
```
ensembl <- useEnsembl(biomart = "genes")
searchDatasets(mart = ensembl, pattern = "SPECIES")
```
The search will return the datasets matching the pattern specified in "SPECIES". We can use this information to extract the species database with:
```
my_ensembl <- useEnsembl(biomart = "genes", dataset = "NAMEOFDATABASE")
```
Now that we have identified our database, we need to extract the transcript ID with their version (as in the kallisto quantification files) and match them to their genes. We first identify how these two sets are named in this ensembl database. The listAttributes() function displays all available attributes in the selected dataset:
```
attributes = listAttributes(my_ensembl)
head(attributes)
```
To match transcripts and genes, we want to select the attributes "ensembl_transcript_id_version" and "ensembl_gene_id". We can extract that information for the whole genome:
```
transcript2gene <- getBM(attributes=c("ensembl_transcript_id_version", "ensembl_gene_id"), mart = my_ensembl, values="")
```
Now we are finally ready to load the Kallisto expression estimates into R using tximport:
```
txi.kallisto.tsv <- tximport(files, type = "kallisto", tx2gene = transcript2gene)
```

### 4.2. Differential expression analyses
We will perform differential expression using [DESeq2](https://bioconductor.org/packages/release/bioc/html/DESeq2.html). To perform differential expression, the first step is to generate a file with the phenotypes. I usually do this outside R (creating manually a tab-delimited file), but it is also relatively easy to do in R. We first generate an empty vector with the dimensions that we want. LetÂ´s say we have 12 samples and 2 conditions, then we need 12 rows and 2 columns (which we can already name):
```
phenotypes = data.frame(matrix(vector(), 12, 2, dimnames=list(c(), c("Condition1", "Condition2"))),stringsAsFactors=F)
```
Now we add the names of the samples as row names:
```
row.names(phenotypes) <- names(txi.kallisto.tsv$infReps)
```
And now we can add the phenotypes for each sample using a vector:
```
phenotypes$Condition1 <- c("A","A","A","A","A","A","B","B","B","B","B","B")
phenotypes$Condition2 <- c("X","X","X","Y","Y","Y","X","X","X","Y","Y","Y")
```
And that generates the object with need with the phenotypes of each sample. As mentioned above, it can also just be generated outside R and loaded as a dataframe with something like "phenotypes <- read.delim('phenotypes.txt', row.names=1)", which is probably more convinient when there are many samples and / or a complex design.

With our expression matrix and our phenotypes, now we are finally ready to generate the DESeq2 object that we are going to use for differential expression:
```
data <- DESeqDataSetFromTximport(txi = txi.kallisto.tsv, colData = phenotypes, design = ~ Condition1 + Condition2)
```
The "design" part of the expression is key. It tells DESeq2 what it needs to test, with the last element being the condition that we want to compare, and previous terms representing potential batch effects. The design can be considerably more complex, including interaction terms (see [DESeq2 vignette](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html)). It can also be modified later on if necessary (and we will show how below).

At this stage and prior to differential expression, it is sensible to explore the overall clustering of the samples to ensure that they behave as expected and discard potential mixing of samples in previous steps. To do so, the data first needs to be normalised, otherwise the most expressed genes would have a very large weight. The raw expression data can be normalised with a variance stabilizing transformation, included as part of DESeq2:
```
vsd <- varianceStabilizingTransformation(data)
```
And to have a quick visualisation of the data, we can use a Principal Components Analysis (PCA) using the DESeq2 function:
```
plotPCA(vsd, intgroup = c("Condition1","Condition2"))
```
However, the options of this function are quite limited, and the figure in not very pretty, so it is better to use the package PCAtools, which also allows visualising the percentage explained by each PCA and plotting more than two PCAs in the same graph. The use of colours and shapes to represent the different conditions also facilitates the interpretation of the PCA results.
```
p <- pca(assay(vsd), metadata = count_info, removeVar = 0.1)
screeplot(p)   #Percentage explained by each PCA
biplot(p, colby = 'Condition1', shape="Condition2", legendPosition = 'top', lab = NULL, legendLabSize = 12, legendIconSize = 6, title = "", pointSize=5)
pairsplot(p, components = c(1:5), triangle = TRUE, trianglelabSize = 12, hline = 0, vline = 0, pointSize = 1, gridlines.major = FALSE, gridlines.minor = FALSE, title = 'Pairs plot', plotaxes = FALSE, margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'), colby = 'Condition1', shape="Condition2")
```
Inspection of the PCA results might lead to the removal of some samples if they are not clustered as expected or to review previous steps and correction of sample assignments. 

Once we are certain our samples are well classified, we can perform differential expression. As mentioned above, the design variable is key, and you will have to adjuste it as necessary. If "Condition1" represents a batch effect, and "Condition2" is the one we want to test, the above design is fine. However, if both variables are important, and we want to test the different combinations, it is better to generate a new variable that combines both original variables.
```
data$combined <- factor(paste0(data$Time, data$Condition))
```
And now we can change the design to test differences in expression according to that variable
```
design(data) <- ~ combined
```
And now we can run the differential expression test. 
```
dds <- DESeq(data)
```
This will compute the comparisons between all the groups in the "combined" variable. To extract the results for a specific comparison:
```
res <- results(dds, contrast=c("combined","AX","BX")) 
```
Keep in mind that the order of the variables is important to estimate fold changes, the first one is the numerator and the second one the denominator.

The object "res" has the results of the differential expression for that comparisons (p-values, fold changes and other statistics), but each gene is only identified with its Ensembl ID. We can again use BiomaRt to obtain their annotation. We can check the "attributes" object again ("attributes = listAttributes(my_ensembl)") and select the ones we are interested in. We will also need the geneID to match it to our data, which we will assign as the name of the rows
```
annotation <- getBM(attributes=c("ensembl_gene_id", "external_gene_name","description"), mart = my_ensembl, values="")
row.names(annotation) <- annotation$ensembl_gene_id
annotation <- annotation[-1]
```
we match the annotation and the differential expression results:
```
res_annotated <- merge(DataFrame(res), annotation, all.x = TRUE, by = "row.names")
```
We can  order the results by adjusted p-value and filter those below your threshold of choice (will potentially depend on the number of differentially expressed genes)
```
res_annotated <- subset(res_annotated[order(res_annotated$padj),], padj < 0.05)
```
Finally, we can save the file in a tab-delimited format to allow inspection using Excel or similar
```
write.table(as.data.frame(res_annotated),file="DE-results.txt", sep="\t", row.names = FALSE)
```

### 4.3. Visualization
An important aspect of any RNA-seq analysis is the visualization of the results. RNA-seq data can be extracted an ploted using any normal software as barplots, boxplots, etc. Here we will show a few that are typical of RNA-seq analyses

#### Volcano Plots
Volcano plots represent the results of a differential expression test. While DESeq2 has an integrated volcano plot, the packages EnhancedVolcano draws nicer and more customisable plots. It takes the results of DESeq2 as input.
```
EnhancedVolcano(res_annotated, x="log2FoldChange", y="padj", lab = "")
```

### Heatmaps
There are multiple packages to facilitate drawing heatmaps, here we will use pheatmap to draw a heatmap for the 50 top differentially expressed genes according to p-value. First we obtain the IDs of those 50 genes:
```
top50 <- res_annotated[1:50,1]
```
The heatmaps are generally drawn with normalised expression values. We can use the "vsd" object generated before. The "assay" option can extract the expression values from "vsd", and we want to do it just for the top50 genes:
```
top50_expression <- assay(vsd[top50])
```
To allow the visualization of all these genes together, the expression values are usually mean centered.
```
top50_expression  <- top50_expression - rowMeans(top50_expression)
```
Now we can draw the heatmap with
```
pheatmap(top50_expression)
```
We can add colours to identify the different sample groups, and also replace the Ensembl IDs with gene names

```
annot <- as.data.frame(colData(vsd)[, c("Condition1","Condition2")])
gene_names <- res_annotated[1:50,"ensembl_gene_id"]
pheatmap(top50_expression, annotation_col = annot, labels_row = gene_names)
```
